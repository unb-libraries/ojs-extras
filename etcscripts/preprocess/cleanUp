#!/usr/bin/perl

use strict;
use warnings;

use Carp;
use List::MoreUtils qw( any );
use Readonly;

# Usage & error messages

Readonly my $USAGE          => 'Usage: cleanUp <file.xml>';
Readonly my $NOT_FOUND      => 'File not found';
Readonly my $NOT_READABLE   => 'File not readable';
Readonly my $NOT_WRITEABLE  => 'File not writeable';

# Replacement patterns
# @todo: remove patterns no longer needed; journal production has
# changed considerably since this script was written.

Readonly my %REPLACEMENTS => (
  '</?(?:web)?normal>'  => q{},
  '<p/>'                => q{},
  '<p>&\#12;</p>'       => q{},
  '&\#7;'               => q{},
  '&\#11;'              => q{},
  '&amp;\#xAD;'         => q{},
  '&\#x201C;'           => '&#x22;',   # left curly double quote
  '&\#x201D;'           => '&#x22;',   # right curly double quote
  '&\#x92;'             => '&#x27;',   # apostrophe
);

# Fairly extensive match for adding links to images in <figure> or <table> elements.
Readonly my $FIGURE => qr{
  <
    (figure|tableau) \s+        # figure or table element ($1)
    .*?                         # attributes, maybe
    id="( [a-z]+ (\d+) )"       # id ($2) and numeric substring of id ($3)
    .*?                         # more attributes
  >    
  .*?                           # elements preceeding <image> tag
  
  (                             # begin image tag capture, $4
    <image \s+ .*?              # attributes, maybe
    id="(im\d+)"                # image id, $5
    .*?                         # attributes, maybe
    typeimage="([^"]+)"         # image type, $6
    .*?>                        # more attributes, maybe
  )                             # end image tag capture
  
  .*?                           # elements following image tag, maybe
  </\1>                         # closing tag for match in $1
}xmsi;

# Define link & pointer target types 
Readonly my $TARGET_LARGE_IMAGE => 'large_image';
Readonly my $TARGET_THUMBNAIL   => 'thumbnail';

# English descriptions of link & pointer target types
Readonly my %TARGET_DESC => (
  $TARGET_LARGE_IMAGE => 'large image',
  $TARGET_THUMBNAIL   => 'thumbnail'
);

# Suffixes to generate unique id labels for links, pointers,
# based on target type.
Readonly my %TARGET_LABEL_SUFFIX => (
  $TARGET_LARGE_IMAGE => 'n',
  $TARGET_THUMBNAIL   => 't',
);

# English labels for image types defined in Érudit DTD
Readonly my %IMAGE_LABEL => (
  'equation'  => 'Equation',
  'figure'    => 'Figure',
  'tableau'   => 'Table',
);

###############################################################################
#  Open & slurp XML file
###############################################################################

# we expect a single file -- complain if we find otherwise
croak $USAGE if scalar @ARGV > 1;

# fine.
my ($xml_file) = @ARGV;

croak $USAGE                      if ! defined $xml_file;
croak "$NOT_FOUND: $xml_file"     if ! -f $xml_file;
croak "$NOT_READABLE: $xml_file"  if ! -r $xml_file;

# slurp contents 
open my $fh, "<", $xml_file or croak $!;
my $content = do { local $/; <$fh> };
close $fh;

###############################################################################
#  Replace patterns defined above and normalize whitespace
###############################################################################

# replace the replacements
foreach my $find (keys %REPLACEMENTS) {
  $content =~ s{ $find }{ $REPLACEMENTS{$find} }xmsige;
}

# normalize the whitespace, but leave line breaks alone
$content =~ s{ [ \t]{2,} }{ }xmsg;

###############################################################################
#  Element numbering
###############################################################################

#
# Sections
#
# Erudit Article 3.0 DTD defines 6 levels of sections to organize content. 
# Section elements are numbered sequentially ACROSS HIERARCHIES, i.e., section
# numbering for level N does not restart at 1 with a change of parent at level
# N-1.
#
{
  Readonly my $SECTION_FIRST => 1;
  Readonly my $SECTION_LAST  => 6;

  # For each section level $sl:
  for my $sl ($SECTION_FIRST..$SECTION_LAST) {
  
    # Match element at current section level. The markup may contain hand-coded
    # id attributes and/or <no> elements: replace & renumber these.
    my $match = qr/<section$sl[^>]*> (?:\s* <no>\d*<\/no>)? /x;

    # initialize section number $sn for current section level 
    my $sn = 1;

    # Add an id attribute and <no> element for all sections at this level
    $content =~ s{ $match }{ "<section$sl id=\"s${sl}n${sn}\"><no>" . $sn++ . "</no>" }xmsge;
  }
}

#
# Paragraphs
#
# Assign a sequentially-numbered id attribute to all <para> elements.
#
# Some <para> elements represent numbered paragraphs: those that do will
# contain an empty <no> element. Add a sequentially-numbered value to all <no>
# elements.  In some cases, the value in <no> will not correspond with the
# value in the id attribute. 
#
{
  my $id = 1;
  $content =~ s{ <para[^>]*> }{ '<para id="pa' . $id++ . '">' }xmsige;

  my $no = 1;
  $content =~ s{ (<para[^>]*>) \s* <no>[^<]*</no> }{ $1 . '<no>' . $no++ . '</no>' }xmsige;
}

#
# Footnotes
#
{
  my $id = 1;
  $content =~ s{ <renvoi[^>]*> }{ '<renvoi id="re1no' . $id . '" idref="no' . $id++ . '" typeref="note">' }xmsige;
}

#
# Notes
#
{
  my $id = 1;
  $content =~ s{ <note[^>]*> \s* <no>[^<]*</no> }{ '<note id="no' . $id . '"><no>' . $id++ . '</no>' }xmsige;
}

#
# Citations
#
{
  my $id = 1;
  $content =~ s{ <refbiblio[^>]*> }{ '<refbiblio id="re' . $id++ . '">' }xmsige;
}

#
# Links
#
{
  my $id = 1;
  $content =~ s{ <liensimple \s+ id="li[^"]*" }{ '<liensimple id="li' . $id++ . '"' }xmsige;
}

###############################################################################
# Table, equation, figure images
###############################################################################

# Build a string of XLink XML for table, equation, and figure images.
my $image_xlink_xml = "";

# Assign each image a numeric id 
my $image_id_no = 0;

FIGURE:
  while ($content =~ /$FIGURE/xmsig) {
  
    my ( $element_id, 
         $element_id_no, 
         $image_tag, 
         $image_id, 
         $image_type ) = ($2, $3, $4, $5, $6);
         
    # Érudit DTD restricts $image_type to defined values;
    # give up if we find an unhandled image type
    
    croak "Unknown image type: $image_type" 
      if ! ( $image_type eq 'figure' || 
             $image_type eq 'equation' || 
             $image_type eq 'tableau' );

    # increment the image id, then
    $image_id_no++;
    
    # helpful comment to group pointeur, link elements
    $image_xlink_xml .= "<!-- Figure $image_id_no -->";

    # Image type 'equation' needs a pointer to a large image only,
    # no thumbnail required
     
    if ($image_type eq 'equation') {
    
      # add pointer to large image of equation
      $image_xlink_xml .= 
        encode_pointer( {
          target_type   => $TARGET_LARGE_IMAGE,
          element_id    => $element_id,
          element_id_no => $element_id_no,
          image_type    => $image_type,
          image_id_no   => $image_id_no,
        });
        
        # we're done here.
        next FIGURE;
    }

    # all other image types require pointer & link to thumbnail,
    # and pointer & link to large image
    
    foreach my $target_type ($TARGET_THUMBNAIL, $TARGET_LARGE_IMAGE) {

      $image_xlink_xml .= 
        encode_pointer( {
          target_type   => $target_type,
          element_id    => $element_id,
          element_id_no => $element_id_no,
          image_type    => $image_type,
          image_id_no   => $image_id_no,
        });
      
      $image_xlink_xml .= 
        encode_link( {
          target_type   => $target_type,
          element_id    => $element_id,
          element_id_no => $element_id_no,
          image_type    => $image_type,
          image_id_no   => $image_id_no,
        });
    }

  } # end FIGURE: while (content matches $FIGURE)

# Add link & pointer XML after '<grlien>' placeholder
$content =~ s/(<grlien[^>]*>)/$1\n$image_xlink_xml/;

# This strikes me as risky.
croak "$NOT_WRITEABLE: $xml_file" if ! open FILE, ">$xml_file";
print FILE $content;
close FILE;

exit 0;

## Utilities to encode <lien>, <pointeur> elements ##

sub encode_pointer {
  my ($arg_ref) = @_;
  
  croak "Usage: fixme" 
    if any { ! defined $arg_ref->{$_} } 
      qw(target_type element_id element_id_no image_type image_id_no);

  my $pointer = <<"END_POINTER";
<!-- $TARGET_DESC{ $arg_ref->{'target_type'} }  as locator -->
<pointeur 
  xlink:href="$arg_ref->{'element_id'}.jpg" 
  xlink:label="im$arg_ref->{'image_id_no'}$TARGET_LABEL_SUFFIX{$arg_ref->{'target_type'}}"
  xlink:title="@{[ ucfirst $TARGET_DESC{$arg_ref->{'target_type'}} ]} of $IMAGE_LABEL{$arg_ref->{'image_type'}} $arg_ref->{'element_id_no'}"
  desc="$arg_ref->{'element_id'}.jpg"
  typemime="image:jpeg"
  xlink:type="locator"/>
END_POINTER

  return $pointer;
}

sub encode_link {
  my ($arg_ref) = @_;
  
  croak "Usage: fixme" 
    if any { ! defined $arg_ref->{$_} } 
      qw(target_type element_id element_id_no image_type image_id_no);
  
  my $link = <<"END_LINK";
<!-- Arc defined for viewing the $TARGET_DESC{$arg_ref->{'target_type'}} -->  
<lien 
  xlink:type="arc" 
  xlink:from="im$arg_ref->{'image_id_no'}"
  xlink:to="im$arg_ref->{'image_id_no'}$TARGET_LABEL_SUFFIX{$arg_ref->{'target_type'}}"
  xlink:title="Display $TARGET_DESC{$arg_ref->{'target_type'}} of $IMAGE_LABEL{$arg_ref->{'image_type'}} $arg_ref->{'element_id_no'}"/>  
END_LINK

  return $link;
}
